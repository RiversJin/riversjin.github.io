<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"riversjin.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://riversjin.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="RiversJin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://riversjin.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://riversjin.github.io/2022/12/07/Atomic-Variable-Demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="RiversJin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/07/Atomic-Variable-Demo/" class="post-title-link" itemprop="url">Atomic Variable Demo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-07 22:50:55" itemprop="dateCreated datePublished" datetime="2022-12-07T22:50:55+08:00">2022-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-08 23:12:00" itemprop="dateModified" datetime="2022-12-08T23:12:00+08:00">2022-12-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接上一篇文章, 这一篇我们来用一些示例程序, 来探讨一下在不同平台下原子变量的行为.</p>
<p>示例代码库我放在了 <a target="_blank" rel="noopener" href="https://github.com/RiversJin/AtomicVariableDemo">https://github.com/RiversJin/AtomicVariableDemo</a><br>使用Rust实现(想顺便温习一下Rust的语法)</p>
<p>项目结构很简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abc@310a0ca1fb3d:~/workspace/t/src$ tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   ├── t1.rs</span><br><span class="line">│   ├── t2.rs</span><br><span class="line">│   ├── t3.rs</span><br><span class="line">│   ├── t4.rs</span><br><span class="line">│   └── t5.rs</span><br><span class="line">└── main.rs</span><br><span class="line"></span><br><span class="line">1 directory, 6 files</span><br></pre></td></tr></table></figure>
<h1 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h1><p>首先是main.rs, 这里比较了两种计数器相加的方法, 一个是使用普通变量全局变量R_MUT, 另一个是使用原子变量R, 其中, 原子变量使用Relaxed的内存序约束.</p>
<p>这种情况下, 无论什么平台, 普通变量的数字都可能会发生错误, 而原子变量正常.</p>
<p>Windows amd64:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\rivers\Desktop\AtomicVariableDemo-master&gt; cargo run  --bin t</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s</span><br><span class="line">     Running `target\debug\t.exe`</span><br><span class="line">R:100000000 r:24134332</span><br><span class="line">PS C:\Users\rivers\Desktop\AtomicVariableDemo-master&gt; cargo run  --bin t</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s</span><br><span class="line">     Running `target\debug\t.exe`</span><br><span class="line">R:100000000 r:24366177</span><br><span class="line">PS C:\Users\rivers\Desktop\AtomicVariableDemo-master&gt; cargo run -r --bin t</span><br><span class="line">    Finished release [optimized] target(s) in 0.01s</span><br><span class="line">     Running `target\release\t.exe`</span><br><span class="line">R:100000000 r:10000004</span><br><span class="line">PS C:\Users\rivers\Desktop\AtomicVariableDemo-master&gt; cargo run -r --bin t</span><br><span class="line">    Finished release [optimized] target(s) in 0.01s</span><br><span class="line">     Running `target\release\t.exe`</span><br><span class="line">R:100000000 r:10000004</span><br></pre></td></tr></table></figure>
<p>可以看到, 如果不使用release配置编译, 普通变量的结果每次都不同, 发生了静态行为.<br>而采用release编译后, 编译器可能对循环相加的操作做出了一些优化, 每次运行的值稳定了, 虽然结果不对.</p>
<p>接下来, 使用弱内存序的Aarch64架构实验, 得到的结论类似:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">abc@310a0ca1fb3d:~/workspace/t/src$ cargo run --bin t</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s</span><br><span class="line">     Running `/config/workspace/t/target/debug/t`</span><br><span class="line">R:100000000 r:74990565</span><br><span class="line">abc@310a0ca1fb3d:~/workspace/t/src$ cargo run --bin t</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s</span><br><span class="line">     Running `/config/workspace/t/target/debug/t`</span><br><span class="line">R:100000000 r:74348213</span><br><span class="line">abc@310a0ca1fb3d:~/workspace/t/src$ cargo run -r --bin t</span><br><span class="line">   Compiling t v0.1.0 (/config/workspace/t)</span><br><span class="line">    Finished release [optimized] target(s) in 2.51s</span><br><span class="line">     Running `/config/workspace/t/target/release/t`</span><br><span class="line">R:100000000 r:10000004</span><br><span class="line">abc@310a0ca1fb3d:~/workspace/t/src$ cargo run -r --bin t</span><br><span class="line">    Finished release [optimized] target(s) in 0.01s</span><br><span class="line">     Running `/config/workspace/t/target/release/t`</span><br><span class="line">R:100000000 r:10000004</span><br></pre></td></tr></table></figure>

<h1 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h1><p>这个测试中, 我们可以看到存在 load-load(读取flag后再读值), store-store(先写值再写flag), 还有load-store(读取完成后清空flag)</p>
<p>t1.rs, t2.rs与t3.rs分别展示了使用普通变量, 误用原子变量以及正常使用原子变量做并发标志位的情形.我们先测试一下Amd64的情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\rivers\Desktop\AtomicVariableDemo-master&gt; cargo run  --bin t1</span><br><span class="line">   Compiling t v0.1.0 (C:\Users\rivers\Desktop\AtomicVariableDemo-master)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.59s</span><br><span class="line">     Running `target\debug\t1.exe`</span><br><span class="line">PS C:\Users\rivers\Desktop\AtomicVariableDemo-master&gt; cargo run  --bin t2</span><br><span class="line">   Compiling t v0.1.0 (C:\Users\rivers\Desktop\AtomicVariableDemo-master)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.52s</span><br><span class="line">     Running `target\debug\t2.exe`</span><br><span class="line">PS C:\Users\rivers\Desktop\AtomicVariableDemo-master&gt; cargo run  --bin t3</span><br><span class="line">   Compiling t v0.1.0 (C:\Users\rivers\Desktop\AtomicVariableDemo-master)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.51s</span><br><span class="line">     Running `target\debug\t3.exe`</span><br></pre></td></tr></table></figure>

<p>而Aarch64下, 稍稍等一会(我这里跑了3分钟), 就可以看到t1, t2出现了异常值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">abc@310a0ca1fb3d:~/workspace/t/src$ cargo run --bin t1</span><br><span class="line">   Compiling t v0.1.0 (/config/workspace/t)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 1.60s</span><br><span class="line">     Running `/config/workspace/t/target/debug/t1`</span><br><span class="line">Get! V1.0=0</span><br><span class="line">^C</span><br><span class="line">abc@310a0ca1fb3d:~/workspace/t/src$ cargo run --bin t2</span><br><span class="line">   Compiling t v0.1.0 (/config/workspace/t)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 1.59s</span><br><span class="line">     Running `/config/workspace/t/target/debug/t2`</span><br><span class="line">Get! V1.0=0</span><br><span class="line">abc@310a0ca1fb3d:~/workspace/t/src$ cargo run --bin t3</span><br><span class="line">   Compiling t v0.1.0 (/config/workspace/t)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 1.61s</span><br><span class="line">     Running `/config/workspace/t/target/debug/t3`</span><br></pre></td></tr></table></figure>

<h1 id="多核心观测写入顺序"><a href="#多核心观测写入顺序" class="headerlink" title="多核心观测写入顺序"></a>多核心观测写入顺序</h1><p>t4.rs与t5.rs简单地复现了一下上篇文章提到的多线程观察修改顺序的问题, 来区分acquire-release与acquire-release. 这个地方和理论上有一些出入. 理论上来说, 对于Aarch64架构, 硬件是不保证多核心的观察必定一致的, 但实际上运行代码会发现, t4与t5使用acquire-release和sequentially-consistent都是不能复现出z&#x3D;&#x3D;0. 这说明其实Aarch64实际上是保证了这个一致性(至少我的Arm架构的路由器是这样). </p>
<p>我在StackOverflow上找到了这样一篇回答, 听上去很有道理, 大家可以参考一下<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/67397460/does-stlrb-provide-sequential-consistency-on-arm64">https://stackoverflow.com/questions/67397460/does-stlrb-provide-sequential-consistency-on-arm64</a></p>
<p>“ARMv8 originally allowed that on paper, but no ARM CPUs ever did.”</p>
<p>更深层次的, 如果不保证这种观察上的一致性, 说明CPU的缓存同步使用的是某种广播机制, 但是工业界的cpu没这么搞, 这篇回答中也提到了只有一些很少的POWER架构的CPU才可能存在这种问题.</p>
<p>所以, 保险起见, 在遇到需要acquire-release语义的原子变量时, 简单使用sequentially-consistent即可, 效率都一样, 反正大部分硬件不支持更灵活的控制.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://riversjin.github.io/2022/10/13/%E6%B5%85%E6%9E%90Rust%E7%9A%84-derive-Clone/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="RiversJin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/13/%E6%B5%85%E6%9E%90Rust%E7%9A%84-derive-Clone/" class="post-title-link" itemprop="url">浅析Rust的#[derive(Clone)]</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-13 22:35:17" itemprop="dateCreated datePublished" datetime="2022-10-13T22:35:17+08:00">2022-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-16 17:53:41" itemprop="dateModified" datetime="2022-10-16T17:53:41+08:00">2022-10-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在学习rust的模板的时候, 我遇到了一个奇怪的问题. 就是关于derive(Clone)这个派生宏的. 有点意思, 跟大家分享一下.</p>
<h1 id="问题来由"><a href="#问题来由" class="headerlink" title="问题来由"></a>问题来由</h1><p>我们先来看这段代码:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">MayNotClone</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CloneByPtr</span>&lt;T&gt; <span class="keyword">where</span> T: MayNotClone&#123;</span><br><span class="line">    item: Rc&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">MustBeClone</span>: <span class="built_in">Clone</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> &lt;T&gt; MustBeClone <span class="keyword">for</span> <span class="title class_">CloneByPtr</span>&lt;T&gt; <span class="keyword">where</span> T:MayNotClone&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>代码本身很简单, 首先声明一个trait叫做MayNotClone, 它不一定满足Clone这个trait, 然后, 再声明一个名为MustBeClone的trait, 这个trait必须实现Clone. 到这里, 一切正常, 对吧?</p>
<p>接下来, 就开始有点奇怪了, 当我们尝试为CloneByPtr这个结构体实现MustBeClone时, 编译器就会报错:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\rivers\Desktop\example&gt; cargo build</span><br><span class="line">   Compiling example v0.1.0 (C:\Users\rivers\Desktop\example)</span><br><span class="line">error[E0277]: the trait bound `T: Clone` is not satisfied</span><br><span class="line"> --&gt; src\main.rs:9:10</span><br><span class="line">  |</span><br><span class="line">9 | impl &lt;T&gt; MustBeClone for CloneByPtr&lt;T&gt; where T:MayNotClone&#123;&#125;</span><br><span class="line">  |          ^^^^^^^^^^^ the trait `Clone` is not implemented for `T`</span><br><span class="line">  |</span><br><span class="line">note: required because of the requirements on the impl of `Clone` for `CloneByPtr&lt;T&gt;`</span><br><span class="line"> --&gt; src\main.rs:4:10</span><br><span class="line">  |</span><br><span class="line">4 | #[derive(Clone)]</span><br><span class="line">  |          ^^^^^</span><br><span class="line">note: required by a bound in `MustBeClone`</span><br><span class="line"> --&gt; src\main.rs:8:20</span><br><span class="line">  |</span><br><span class="line">8 | trait MustBeClone: Clone &#123;&#125;</span><br><span class="line">  |                    ^^^^^ required by this bound in `MustBeClone`</span><br><span class="line">  = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)</span><br><span class="line">help: consider further restricting this bound</span><br><span class="line">  |</span><br><span class="line">9 | impl &lt;T&gt; MustBeClone for CloneByPtr&lt;T&gt; where T:MayNotClone + std::clone::Clone&#123;&#125;</span><br><span class="line">  |                                                            +++++++++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `example` due to previous error</span><br></pre></td></tr></table></figure>

<p>编译器提示得很清晰, MustBeClone这个trait要求实现它的结构体必须满足trait, 但是T(也就是那个MayNotClone)不满足Copy的trait, 请考虑为T添加一个clone trait的限制.</p>
<p>我不是加了#[derive(Clone)]么, 怎么还不好使. </p>
<p>这个就有点无理取闹了啊. 这个CloneByPtr明明持有的是T的指针, 你指针能复制就好了嘛, 要指针指向的值能复制做干嘛. </p>
<h1 id="我们来看一下-derive-Clone-吧"><a href="#我们来看一下-derive-Clone-吧" class="headerlink" title="我们来看一下#[derive(Clone)]吧!"></a>我们来看一下#[derive(Clone)]吧!</h1><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/clone/trait.Clone.html#derivable">https://doc.rust-lang.org/std/clone/trait.Clone.html#derivable</a></p>
<p>根据官方文档说, This trait can be used with #[derive] if all fields are Clone.<br>如果一个struct的全部field都是Clone的, 那这个宏可以让这个struct也变为Clone的.</p>
<p>那我这个没毛病啊, std::rc::Rc不是实现了Clone么. 它直接生成item.clone()不就完事了么.</p>
<p>那问题出在哪了呢? 我觉得应该还是在于derive(Clone)上, 我们来研究一下这个宏, 看看怎么回事.</p>
<p>首先, 让我们先考虑一下, 这个宏都干了什么. 如果不用它, 我们自己手动实现Clone, 应该是什么样子呢? 下面我们以一个比较简单的struct举个栗子</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImStruct</span>&#123;</span><br><span class="line">    a: <span class="type">i32</span>,</span><br><span class="line">    b: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果为它实现Clone那么就应该是</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Clone</span> <span class="keyword">for</span> <span class="title class_">ImStruct</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    Foo &#123;</span><br><span class="line">      a: <span class="keyword">self</span>.a.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">      b: <span class="keyword">self</span>.b.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果加入泛型呢? 像这样:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImGenericStruct</span>&lt;T, U&gt; &#123;</span><br><span class="line">  a: <span class="type">u32</span>,</span><br><span class="line">  b: Rc&lt;T&gt;,</span><br><span class="line">  c: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那如果为它实现Clone就应该是:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">ImGenericStruct</span>&lt;T, U&gt; &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    Foo &#123;</span><br><span class="line">      a: <span class="keyword">self</span>.a.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">      b: <span class="keyword">self</span>.b.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">      c: <span class="keyword">self</span>.c.<span class="title function_ invoke__">clone</span>(), <span class="comment">// 这里8行, C类型不一定</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以如果想要为这个struct实现Clone, 就必须确保U是Clone的:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImGenericStruct</span>&lt;T, U: <span class="built_in">Clone</span>&gt; &#123;</span><br><span class="line">  a: <span class="type">u32</span>,</span><br><span class="line">  b: Rc&lt;T&gt;,</span><br><span class="line">  c: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里, 一切正常, 对吧? 那#[derive(Clone)]问题出在哪了呢? 这个简单, 我们直接看它生成了什么代码就可以了. 比如gcc,clang, 有一个-E参数, 可以显示模板,宏展开后的代码. rust也有这个功能, 不过需要使用nightly版本的才可以启用此特性.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rustup toolchain install nightly </span><br><span class="line">cargo install cargo-expand </span><br><span class="line">rustup default nightly <span class="comment">#这里将rust暂时切换为nightly的版本, 记得之后改回去</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/dtolnay/cargo-expand">cargo-expand</a></p>
<p>我们以上面 struct ImGenericStruct&lt;T, U&gt; 为例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ImGenericStruct</span>&lt;T, U&gt; &#123;</span><br><span class="line">  a: <span class="type">u32</span>,</span><br><span class="line">  b: Rc&lt;T&gt;,</span><br><span class="line">  c: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其展开代码为:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImGenericStruct</span>&lt;T, U&gt; &#123;</span><br><span class="line">    a: <span class="type">u32</span>,</span><br><span class="line">    b: Rc&lt;T&gt;,</span><br><span class="line">    c: U,</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[automatically_derived]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ::core::clone::<span class="built_in">Clone</span>, U: ::core::clone::<span class="built_in">Clone</span>&gt; ::core::clone::<span class="built_in">Clone</span></span><br><span class="line"><span class="keyword">for</span> <span class="title class_">ImGenericStruct</span>&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> ImGenericStruct&lt;T, U&gt; &#123;</span><br><span class="line">        ImGenericStruct &#123;</span><br><span class="line">            a: ::core::clone::<span class="built_in">Clone</span>::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.a),</span><br><span class="line">            b: ::core::clone::<span class="built_in">Clone</span>::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.b),</span><br><span class="line">            c: ::core::clone::<span class="built_in">Clone</span>::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.c),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见, derive(Clone)画蛇添足地为T添加了Clone限制. emm, 这是rust的宏自身的限制, 它能做到读取代码的token流用来自动生成一些其他代码, 但是应该还不具备与编译器交互的能力, 也就没办法在宏展开时做出完善的类型检查, 所以只能简单粗暴地为里面出现的每一个模板参数都直接加上Clone的限制… 也许有一些其他的trait能避开这个问题, 不过直接手动实现一下, 也是一个可以考虑的方案.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://riversjin.github.io/2022/10/04/Atomic-Variable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="RiversJin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/04/Atomic-Variable/" class="post-title-link" itemprop="url">Atomic Variable & Memory Order</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-04 21:26:37" itemprop="dateCreated datePublished" datetime="2022-10-04T21:26:37+08:00">2022-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-05 12:59:53" itemprop="dateModified" datetime="2022-11-05T12:59:53+08:00">2022-11-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一篇文章, 我们浅谈一下原子变量以及内存序模型. 有什么问题欢迎留言指出, 我们可以一起讨论.</p>
<h1 id="Atomic-Variable"><a href="#Atomic-Variable" class="headerlink" title="Atomic Variable"></a>Atomic Variable</h1><p>首先我们先来聊一下什么是”原子性”. 假如有这样一段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    v = v + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行add函数时, CPU需要先从内存中取出v的值, 然后计算+2, 最后写回到内存中. 如果只有一个执行序, 那当然无所谓. 但如果有并发呢? 那就比较麻烦了. 我们讨论最简单的情况, 即双线程并发执行一次这个函数.</p>
<p>这就可能出现多种情况. 比如, 其中一个线程先执行成功, 然后另一个线程执行. 那么当二者都执行成功后. v的值变为4. </p>
<p>或者, 它们一起开始执行. 线程1先读取到v的值, 开始计算+2, 但还没来得及写回; 而线程2已经开始运行, 开始读取v值, 为0, 开始计算+2. 最终, 无论这两个执行绪谁先执行完成, 都会只是向内存写入2. 而不是预期中的4. 就像下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> T0             T1</span><br><span class="line">┌──────────────┬───────────────┐</span><br><span class="line">│  load v (=0) │               │</span><br><span class="line">├──────────────┼───────────────┤</span><br><span class="line">│              │  load v (=0)  │</span><br><span class="line">├──────────────┼───────────────┤</span><br><span class="line">│  add 2  (=2) │  add 2 (=2)   │</span><br><span class="line">├──────────────┼───────────────┤</span><br><span class="line">│              │  store v (=2) │</span><br><span class="line">├──────────────┼───────────────┤</span><br><span class="line">│ store v (=2) │               │</span><br><span class="line">└──────────────┴───────────────┘</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>从这段代码来说, 这个+2的操作, 显然就不是原子性的. 如果是”原子性”的操作, 那就该这三个步骤合并为一个步骤, 一下子完成. 像这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> T0             T1</span><br><span class="line">┌──────────────┬───────────────┐</span><br><span class="line">│     v+=2     │               │</span><br><span class="line">├──────────────┼───────────────┤</span><br><span class="line">│              │               │   // v == 2</span><br><span class="line">├──────────────┼───────────────┤</span><br><span class="line">│              │     v+=2      │   </span><br><span class="line">└──────────────┴───────────────┘</span><br><span class="line">                                   // v == 4</span><br></pre></td></tr></table></figure>
<p>或者, 我们可以直接简单地加一个互斥锁, 让f不要并行执行, 也可以.</p>
<p>但是, 比较反直觉的是, 即使我们不讨论对变量修改并写回的操作, 只考虑单纯地读取一个变量或者加一个变量(Load&#x2F;Store)也不一定是原子性的. 这个就涉及到一些硬件上的原理, 比如, 某种平台, 每次只能读取内存中4个字节, 那如果在这种平台上, 读取一个int64即8个字节的值, CPU就不得不读取两次, 先读取一半, 再读取另一半. 或者在普通我们常见的平台, 也可能出现这种问题, 比如变量没有对齐, 那么CPU就有可能也不得不将一次读取拆分为多次.</p>
<pre><code>另外多说一句, 如果使用gcc/clang-x64并打开优化, 可以观察到add函数被编译为
    add():                                # @add()
    add     dword ptr [rip + v], 1
    ret
看起来像是一条单个的add汇编指令, 似乎是满足了上文提到的&quot;原子性&quot;加法, 将三个操作合并为一个, 但这并不意味着这个加法操作就是原子性的, 只是CPU内部将这一条指令分成多个步骤执行了而已. 对此感兴趣的朋友可以搜索一下关键词&quot;CISC 微指令&quot;
</code></pre>
<p>在类似于amd64这种强内存序(Strong memory order)下, 如果变量已经对齐, 那其实不需要纠结什么, 对于整数的读取和写入本身就已经是原子的. 现代的编译器在生成变量时会注意内存对齐的问题. 所以毫不夸张的说, 如果说我们只讨论单一变量的原子性读和写, 并且只讨论amd64或x86架构的话, 那么这个话题就结束了. 没有什么需要注意的, 它们天然就是原子性的. 就当是普通地读取变量即可. </p>
<p>那如果类似于aarch64这类的弱内存(Weak memory order)呢? 那就需要稍微注意一下了, 在这种架构下, 如果是没有对齐的存取, 就很有可能喜提Alignment fault.</p>
<pre><code>比如MIPS和低版本的ARM会不支持对齐访问. 高版本的ARM比如aarch64倒是支持, 不过也很有限(栈和指令依旧必须对齐), 并且性能会有损失
</code></pre>
<p>那么好, 我记住了, 以后存取变量注意内存对齐, 结束, 下课~</p>
<p>别急, 还没讲完 :P</p>
<p>从我个人的观点来看, 所谓”原子变量”是一个很有迷惑性的术语, 它会让人误以为所谓”原子性”仅仅是指对于单个变量的原子性操作. 实际上, 当我们谈论原子变量时, 我们更多地是在讨论基于原子变量的缓存控制.<br>也就是并发编程的三要素–原子, 有序, 可见中的后面两位, 有序性&amp;&amp;可见性.</p>
<h1 id="内存序模型"><a href="#内存序模型" class="headerlink" title="内存序模型"></a>内存序模型</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>我们首先说可见性. 可见性是指, 当一个执行绪修改了内存上的一个变量, 其他执行绪应该能”看见”这次修改. 在现代CPU架构下, 这点其实并不是一定的, 比如Java下的<em>volatile</em>关键字, 就是要确保其他线程能看到这次变量的修改.</p>
<pre><code> 不过, 在C/C++下, *volatile*有着其他的意义, 我的建议是, 在写C/++时, 如果你不是在处理硬件相关的东西, 就不要用.
</code></pre>
<p>那如何保证可见性呢? 这个我们和下面的有序性一起讲.</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>为了提高执行性能, 现代的编译器,以及CPU都会对执行指令进行重排. 不过重排还是有一个前提, <strong>不影响单执行绪下的执行结果</strong>,我们可以看一下这一段代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    a = a + <span class="number">1</span> ;</span><br><span class="line">    b = b + <span class="number">2</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用armv8-a clang 10.0.0开启O1优化, 可以得到下面的汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f():                                  // @f()</span><br><span class="line">        adrp    x8, a</span><br><span class="line">        adrp    x9, b</span><br><span class="line">        ldr     w10, [x8, :lo12:a]</span><br><span class="line">        ldr     w11, [x9, :lo12:b]</span><br><span class="line">        add     w10, w10, #1            // =1</span><br><span class="line">        add     w11, w11, #2            // =2</span><br><span class="line">        str     w10, [x8, :lo12:a]</span><br><span class="line">        str     w11, [x9, :lo12:b]</span><br><span class="line">        ret</span><br><span class="line">a:</span><br><span class="line">        .word   0                       // 0x0</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">        .word   0                       // 0x0</span><br></pre></td></tr></table></figure>
<p>可以看到, 编译器生成的汇编指令先读取两个变量的值, 然后相加, 最后写回两个变量.<br>如果不优化, 那么生成的汇编就会是 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">f():                                  // @f()</span><br><span class="line">        adrp    x8, a</span><br><span class="line">        add     x8, x8, :lo12:a</span><br><span class="line">        adrp    x9, b</span><br><span class="line">        add     x9, x9, :lo12:b</span><br><span class="line">        ldr     w10, [x8]</span><br><span class="line">        add     w10, w10, #1            // =1</span><br><span class="line">        str     w10, [x8]</span><br><span class="line">        ldr     w10, [x9]</span><br><span class="line">        add     w10, w10, #2            // =2</span><br><span class="line">        str     w10, [x9]</span><br><span class="line">        ret</span><br><span class="line">a:</span><br><span class="line">        .word   0                       // 0x0</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">        .word   0                       // 0x0</span><br></pre></td></tr></table></figure>
<p>这下, 编译器生成的汇编和我们写的c代码基本就是逐行对应的了.</p>
<p>不仅如此, 除了编译器, CPU内部在硬件层面上, 也会对指令进行重新排序, 所以, 如果以为加了编译屏障, 就万事大吉, 显然是不可能的. </p>
<pre><code>编译器屏障, 通常见到的都是这样的:
__asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)
这个东西, 还是那句话, 除非你真的知道自己在做什么再用, 如果希望使用它来禁止指令重排, 保证有序性, 那它大概率是做不到的.
</code></pre>
<p>相比于编译器造成的指令重排, 硬件造成的重排, 要更为棘手, 这不仅涉及到指令重排这么简单, 还会影响CPU多层缓存的更新. </p>
<p>比如, 因为有缓存的存在, CPU0修改了内存上的某个值, 但是因为配置的缓存策略是”Write Back”, 此次修改还没来得及写回到内存上, 只是CPU0独享的缓存中, 此时其他CPU核心就读不到最新的修改.</p>
<p>那是不是等这次写回完成后就可以了呢? 无非就是等一等而已. 但是问题要更复杂一些, 上文说到, 不仅是编译器, CPU本身还会对指令进行重排以提高性能. 假如有这样一段代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_v</span><span class="params">()</span></span>&#123;</span><br><span class="line">    v = <span class="number">42</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_v</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数set_v中, 首先对v赋值, 然后对flag置位. 然后在get_v中, 会轮询标志位, 当标志位非0时, 代表变量v准备好, 可以被读取, 读取v的值后返回.</p>
<p>但是这段代码, 在一些CPU平台上, 大概率是不能运行的. 两个函数都可能存在问题.</p>
<p>首先说set_v, 因为CPU乱序执行以及缓存的缘故, 可能出现下面的情况</p>
<ol>
<li>flag &#x3D; 1有可能先于v&#x3D;42执行, 被写入到内存.</li>
<li>v&#x3D;42确实在flag&#x3D;1之前执行了, 但只是写入到缓存中. 而随后的缓存写回时, flag所在的缓存先于v&#x3D;42被写回. 导致其他线程先观察到了flag置位, 然后立即去读取v的值, 但是内存上v还没有被更新, 就会导致读出的值是错误的.</li>
</ol>
<p>然后再说get_v, 在被乱序执行后, 可能它会有自己的关于v的缓存, 还未更新, 或者说, 更新的晚于flag所在的缓存, 这也可能导致读出错误.</p>
<pre><code>当然, 你可能会提到缓存一致性协议, 会保证执行结果的. 但是, 缓存一致性协议是需要一些hint才会工作的, 不然所有核心全用同一个缓存算了. 具体是什么hint, 我们下面马上就讲
</code></pre>
<p>set_v可能出现的两种状况中, 如果我们作为一个观察者观察内存时, 看到的结果其实是一样的, 都是修改了flag, 后修改了v.</p>
<p>或者说, 我们如何定义store操作的完成呢? 是写到缓存就算执行完成呢? 还是写到内存才算一条store指令执行完成? </p>
<p>如果是后者的话, 那么其实那两种情况, 指的就是同一种, 即store flag的指令错误地先于store v的指令执行了. 那我们可以简化一下, 假设我们不知道缓存的存在, 就只考虑存取指令的乱序执行. 在这种情况下, 我们就只考虑指令之间的排列顺序即可. 假如一个指令完成, 那就意味着store已经将值写到内存.</p>
<pre><code>只是简化理解噢, 实际上L2及以下的缓存是核心共享的, 那么就意味着这种store, load只要读取到缓存上的最新值即可. 但是对于总线上的其他设备, 可能又不行. 所以大家不必纠结这个, 暂时忘掉缓存即可:P
</code></pre>
<p>在这种简化模型下, 如果要保证存取指令之间执行的有序性, 我们可以简单地插入一些屏障指令, 禁止一些CPU的重排行为, 这样, 强制存取指令按照约定的顺序执行, 就不会再有莫名其妙的重排问题了, 这也就是下面讲的东西, 内存屏障.</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>上文提到了, 有编译器屏障, 那么自然, 也就存在CPU的指令屏障. </p>
<p>各个平台都会提供一些特别的汇编指令, 我们可以称之为”完全内存屏障”, 硬件保证: 这条指令之前的指令一定会在这条指令执行前执行完成, 这条指令之后的指令一定在这条指令完成之后开始执行. </p>
<pre><code>x86下是LFENCE,SFENCE,MFENCE,或者什么带有lock前缀的指令, 或者什么隐含锁语义的指令(比如exchg)
而aarch64下, 则是DMB, DSB, ISB指令
</code></pre>
<p>但是, 这种屏障指令, 有的时候可能粒度过大. </p>
<p>比如, 对于我们常见的内存变量存取, 我们只需要保证相应的load, store指令之间不要重排即可. 没必要让所有指令都跟着一起停下来. 因为这样需要让整个CPU流水线都会被排空, 同时缓存也要完全同步一次才能实现. 相对来说, 性能上还有进一步提升的空间.</p>
<p>所以, 因此就出现了更加细致的内存屏障指令. 在不少平台上, 都会存在类似这种细粒度的屏障指令, 只禁止某些特定的指令重排, 这样可以对缓存更新行为做更细粒度的控制, 也就相对可以获得更高的性能.</p>
<p>那么, 考虑最简单的情况, 即两个存取指令, 可以有4种情况. 那么根据这四种情况, 就需要四种内存屏障.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┬───────────────┐</span><br><span class="line">│  load, load  │  load, store  │</span><br><span class="line">├──────────────┼───────────────┤</span><br><span class="line">│ store, load  │  store, store │</span><br><span class="line">└──────────────┴───────────────┘</span><br></pre></td></tr></table></figure>

<p>我们接下来, 用一些例子, 来尝试解释一些这些屏障的行为</p>
<h4 id="load-load"><a href="#load-load" class="headerlink" title="load-load"></a>load-load</h4><p>load-load 屏障可以保证, 两个读取行为间不会被乱序. 但是要注意, 这其实并不保证读取到的就一定是最新的值. 准确来说, 它只保证第一次读取到的值, 比第二次读取到的更老. </p>
<pre><code>这个屏障就可以用来实现上面的get_v函数.像这样:
int get_v()&#123;
    while(flag == 0)&#123;
        continue;
    &#125;
    *LOAD_LOAD_FENCE();*
    return v;
&#125;
只要读取到flag被置位, 再加上一个load-load屏障, 就可以确保接下来读取v的动作发生在读取flag之后.保证了读取行为的正确性
</code></pre>
<h4 id="Store-store"><a href="#Store-store" class="headerlink" title="Store-store"></a>Store-store</h4><p>Store-Store 屏障与load-load类似, 它保证两个写入行为间不会乱序. 并且和load-load一样, 它不保证屏障之前的值一定是完成了的, 只是保证, 在内存视角, 前面的修改一定是先于后面的修改.</p>
<pre><code>这个屏障可以用来实现上面set_v函数
void set_v()&#123;
    v = 42;
    *STORE_STORE_FENCE()*
    flag = 1;
&#125;
</code></pre>
<h4 id="Load-store"><a href="#Load-store" class="headerlink" title="Load-store"></a>Load-store</h4><p>指令重排&#x2F;乱序执行有一个重要前提, 那就是不会更改单线程下的执行结果. 所以, Load-Store的重排听起来可能有点奇怪? 假如, 必须先读取到一个特定的标志位, 才能开始写入. 那这种重排不就会影响单线程下的执行结果了. </p>
<p>比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">0</span>)&#123;</span><br><span class="line">        v = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像是这种, 即使乱序执行, 也肯定不会影响语义.</p>
<p>所以, 这种重排只会发生在一些特殊情况. 当前面的load指令读取恰好遇到了cache miss并且load,store的变量之间完全没有联系的情况下. 还是可能发生这种重排的.</p>
<p>比如有下面f,g两个函数分别有core1和core2执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="comment">// execute by core 1</span></span><br><span class="line">    <span class="type">int</span> t0 = x;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123; <span class="comment">// execute by core 2</span></span><br><span class="line">    <span class="type">int</span> t1 = y;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果f先执行, 那么可以得到</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>t0</th>
<th>t1</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>如果g先执行, 那么可以得到</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>t0</th>
<th>t1</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>或者二者交替执行, 即两个读取x,y的先执行, 对x,y后执行的可以得到</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>t0</th>
<th>t1</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>但是, 如果发生了load-store重排, 最终也可能获得x &#x3D;&#x3D; y &#x3D;&#x3D; t0 &#x3D;&#x3D; t1 &#x3D;&#x3D; 1的结果</p>
<h4 id="Store-load"><a href="#Store-load" class="headerlink" title="Store-load"></a>Store-load</h4><p>Store-load相对来说是最”重”的屏障, 它要确保load在Store<strong>执行完成</strong>之后才能读取. 还记得我们之前定义的Store操作吧? Store指令的完成, 意味着修改写入到内存, 让其他观察者可见. 并且, 读取到的值, 一定是最新可见的值.</p>
<p>以上, 就是各种单向内存屏障的定义. 但实际上, 我们实际在编程时极少直接使用这类屏障指令. 一方面, 不同平台的屏障指令特点都不尽相同, 不能完全和这些标准的屏障对应; 另一方面, 直接使用屏障对于使用高级语言编程来说, 可能过于底层了, 从这个角度来说, 我们应该告诉编译器我们想要达成什么效果, 而不是直接告诉编译器使用什么指令. 那这就引出我们今天最后的内容了—-内存序.</p>
<pre><code>比如, x86, amd64, 安腾架构是所谓的&quot;强内存序(Strong memory order)&quot;, 平台会保证在一些情况下不会乱序执行. 以amd64为例, 它只需要store-load屏障, 其余情况不会发生乱序执行.
或者类似于Aarch64, 它不提供任何保证, 所有执行情况必须由显式的屏障指令才能保证其不会重排, 也就是所谓的&quot;弱内存序(Weak memory order)&quot;
</code></pre>
<h3 id="内存序-memory-order"><a href="#内存序-memory-order" class="headerlink" title="内存序 (memory order)"></a>内存序 (memory order)</h3><p>C++11定义了6种内存序(memory order), 用来控制对原子变量的读写. 当访问原子变量时, 需要给出一个内存序参数, 通过这个参数, 就可以控制以这个原子变量为分界线的内存乱序执行行为. 编译器会根据对应的内存序, 生成不同的屏障指令.</p>
<ol>
<li>relaxed</li>
<li>acquire</li>
<li>release</li>
<li>acquire-release</li>
<li>consume</li>
<li>sequentially-consistent</li>
</ol>
<p>我们接下来一个一个讲</p>
<h4 id="relaxed"><a href="#relaxed" class="headerlink" title="relaxed"></a>relaxed</h4><p>Relaxed 是最轻的内存序限制, 它只保证对于指定的原子变量的操作是原子的, 而对于在访问原子变量周围的同步或者内存重排行为, 则一概不管. 所以显而易见, 这也是原子变量中性能最好的内存序. 不过嘛, 似乎只能用来做计数器? 如果涉及到多个变量的同步都可能发生问题.</p>
<h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h4><p>Acquire 要求, 在读取到此原子变量后面的<strong>所有</strong>读取&#x2F;写入指令, 不可以被重排到读取此原子变量的前面. 这个就非常适合用于我们上面的get_v</p>
<pre><code>相当于load-store+load-load两个屏障加在一起
</code></pre>
<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>与acquire相反, release要求, 在写入此变量之前的<strong>所有</strong>读取&#x2F;写入指令, 不可以重排到写入此原子变量的后面. 适合我们刚才的set_v.</p>
<pre><code>相当于store-store+load-store两个屏障相加
</code></pre>
<h4 id="acquire-release"><a href="#acquire-release" class="headerlink" title="acquire-release"></a>acquire-release</h4><p>这个就是Acquire和release的相加在一起, 相当于一次完全内存屏障. 这种内存序需要一次read-modify-write操作, 既有acquire又有release. 用在两个线程交换什么东西的时候.</p>
<pre><code>这个所谓的read-modify-write操作要和上面的计数器做一些区分. 计数器加1当然也是read-modify-wirte,但是只是相对于原子变量自身而言. 比如, 两个线程需要交换指针, 这种情况, 就需要acquire-release语义了.
</code></pre>
<h4 id="sequentially-consistent"><a href="#sequentially-consistent" class="headerlink" title="sequentially-consistent"></a>sequentially-consistent</h4><p>序列化一致性和acquire-release区别不大. 比如, 在单生产者单消费者的情况下, 二者没有区别. 区别在于多线程的情况下, 序列化一致性保证, 多个线程观察到修改时, 顺序是一致的.</p>
<p>比如有4个线程, 分别执行a, b, c, d四个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t1 = <span class="number">0</span>, t2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t2 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(t1 == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(t2 == <span class="number">1</span>)z+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">d</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(t2 == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(t1 == <span class="number">1</span>)z+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c函数执行时, 如果t1先于t2赋值, 是有可能不执行z+&#x3D;1的. 同理, 对于d函数来说, 如果t2先于t1赋值, 也是有可能不执行z+&#x3D;1的. 那么按照直觉来说, d或者c应该至少有一个将z+&#x3D;1, 对吧? 其实不一定. 如果不使用序列化一致性模型, C++标准不保证两个线程观察到的赋值顺序是相同的.</p>
<pre><code>多说一句, 如果用的是amd64, 硬件保证所有线程观察到的顺序是一定的, 在这个平台上, 是看不到z==0的, 硬件上没有这种灵活性...
</code></pre>
<h4 id="consume"><a href="#consume" class="headerlink" title="consume"></a>consume</h4><p>那这种内存序就比较高端了. 它和acquire-release类似, 但是粒度更细一点. 假如一个线程通过这个内存序load的一个值, 那么**与这个值相关(或者叫数据依赖 carries dependency)<strong>的load和store, 不能重排到前面; 如果通过这个内存序Store一个值, 那么</strong>与这个值相关(或者叫数据依赖 carries dependency)**的load和store, 不能重排到后面. </p>
<p>但是实际上, 好像还没有硬件平台支持这么细粒度的屏障. 所以这个内存序只会影响一些编译器优化的行为(比如编译器可能会禁止预加载依赖链上的数据).</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>这篇关于原子变量的文章到这里就结束了, emm 也没有完全结束, 还都是理论介绍, 没有实际的代码例子, 之后我会再写一篇实操的(咕咕咕咕).</p>
<p>但其实我最想说的是, 大部分情况, 除了计数器这种非常简单的需求, 没事不要折腾什么无锁编程, 性能不一定快多少, 但可以保证的是bug会很难调. 很多时候程序的瓶颈根本就不差这几个锁, 现在的Linux的futex什么的, 用锁其实也没慢多少的… 同理, 你确定一定要用原子变量的时候, 就直接用顺序一致性就好, 也没差多少, 尤其是在x86这种平台, 很多细粒度的屏障都是不支持的, 没有什么搞事的余地:(</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://riversjin.github.io/2021/10/11/Mit6824/MIT-6-824-Lab1-%E8%A6%81%E6%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="RiversJin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/11/Mit6824/MIT-6-824-Lab1-%E8%A6%81%E6%B1%82/" class="post-title-link" itemprop="url">MIT 6.824 Lab1 要求</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-11 20:35:19" itemprop="dateCreated datePublished" datetime="2021-10-11T20:35:19+08:00">2021-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-04 14:06:37" itemprop="dateModified" datetime="2022-10-04T14:06:37+08:00">2022-10-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT-6-824/" itemprop="url" rel="index"><span itemprop="name">MIT 6.824</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一篇文章主要是对实验1要求的翻译 以及顺便需要记录的碎碎念.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote>
<p>In this lab you’ll build a MapReduce system. You’ll implement a worker process that calls application Map and Reduce functions and handles reading and writing files, and a coordinator process that hands out tasks to workers and copes with failed workers. You’ll be building something similar to the MapReduce paper. (Note: the lab uses “coordinator” instead of the paper’s “master”.)</p>
</blockquote>
<p>在这个实验中,你需要实现一个MapReduce系统.你需要实现一个调用<em>Map</em>和<em>Reduce</em>的worker process. 以及一个负责将任务分发到worker process并处理work process错误的coordinator process. </p>
<h2 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h2><blockquote>
<p>You’ll fetch the initial lab software with git (a version control system). To learn more about git, look at the Pro Git book or the git user’s manual. To fetch the 6.824 lab software:</p>
</blockquote>
<p>通过git拉取代码,如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://g.csail.mit.edu/6.824-golabs-2021 6.824</span><br><span class="line">$ <span class="built_in">cd</span> 6.824</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">Makefile src</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<blockquote>
<p>We supply you with a simple sequential mapreduce implementation in src&#x2F;main&#x2F;mrsequential.go. It runs the maps and reduces one at a time, in a single process. We also provide you with a couple of MapReduce applications: word-count in mrapps&#x2F;wc.go, and a text indexer in mrapps&#x2F;indexer.go. You can run word count sequentially as follows:</p>
</blockquote>
<p>在src&#x2F;main&#x2F;mrsequential.go中,以及实现了一个简单的顺序的MapReduce实现(即非并发的版本).它在一个进程中,执行<em>map</em>和<em>reduce</em>.</p>
<p>另外,还提供了一些MapReduce的应用程序,比如mrapps&#x2F;wc.go的word count,以及mrapps&#x2F;indexer.go的文本索引器.</p>
<p>以下的命令可以以顺序版本执行word count:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/6.824</span><br><span class="line">$ <span class="built_in">cd</span> src/main</span><br><span class="line">$ go build -race -buildmode=plugin ../mrapps/wc.go</span><br><span class="line">$ <span class="built_in">rm</span> mr-out*</span><br><span class="line">$ go run -race mrsequential.go wc.so pg*.txt</span><br><span class="line">$ more mr-out-0</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>注意: 如果编译的时候没有-race参数,那么运行的时候也不可加-race参数</strong></p>
<blockquote>
<p>-race参数是golang内置的竞态检测,一般来说,内存使用增加5-10倍,运行速度减慢2-20倍.<br>具体参考 <a target="_blank" rel="noopener" href="https://golang.org/doc/articles/race_detector">https://golang.org/doc/articles/race_detector</a></p>
</blockquote>
<h2 id="Your-Job"><a href="#Your-Job" class="headerlink" title="Your Job"></a>Your Job</h2><blockquote>
<p>Your job is to implement a distributed MapReduce, consisting of two programs, the coordinator and the worker. There will be just one coordinator process, and one or more worker processes executing in parallel. In a real system the workers would run on a bunch of different machines, but for this lab you’ll run them all on a single machine. The workers will talk to the coordinator via RPC. Each worker process will ask the coordinator for a task, read the task’s input from one or more files, execute the task, and write the task’s output to one or more files. The coordinator should notice if a worker hasn’t completed its task in a reasonable amount of time (for this lab, use ten seconds), and give the same task to a different worker.</p>
</blockquote>
<p>你的工作是实现一个分布式的MapReduce.它主要由Worker和Coordinator组成. 一个Coordinator与若干个Worker并行执行. 在真实系统中,这些进程会在不同的机器上运行,但是对于这个实验来说,Coordinator与Worker会在同一个机器上执行. 进程间通过RPC通信.Workder会向Coordinator请求发布任务,从一个或若干个文件中读取输入,执行任务,并将输出写另一些文件中.Coordinator要注意到每个Workder是否在合理的时间内完成任务(在这个实验中,这个时间是10s),如果没有,将这个任务交给另一个Worker</p>
<blockquote>
<p>We have given you a little code to start you off. The “main” routines for the coordinator and worker are in main&#x2F;mrcoordinator.go and main&#x2F;mrworker.go; don’t change these files. You should put your implementation in mr&#x2F;coordinator.go, mr&#x2F;worker.go, and mr&#x2F;rpc.go.</p>
</blockquote>
<p>我们已经给了你一小部分代码.Worker和Coordinator的main routine位于main&#x2F;mrcoordinator.go和main&#x2F;mrworker.go中.不要更改这些文件。您应该将实现放在mr&#x2F;coordinator.go、mr&#x2F;worker.go和mr&#x2F;rpc.go中。</p>
<blockquote>
<p>Here’s how to run your code on the word-count MapReduce application. First, make sure the word-count plugin is freshly built:</p>
</blockquote>
<p>以下,介绍如何使用你的代码运行word count.首先,确保word-count是最新构建出的:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -race -buildmode=plugin ../mrapps/wc.go</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In the main directory, run the coordinator.<br>在main目录中,运行Coordinator程序</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> mr-out*</span><br><span class="line">$ go run -race mrcoordinator.go pg-*.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The pg-*.txt arguments to mrcoordinator.go are the input files; each file corresponds to one “split”, and is the input to one Map task. The -race flags runs go with its race detector.</p>
</blockquote>
<p>传入”pg-*.txt”参数到mrcoordinator.go是输入文件,每个文件都是一个”切片”(即输入文件已经被拆分为若干个小文件了),这对应一个Map task. -race 参数告诉编译器启用竞态检测.</p>
<blockquote>
<p>In one or more other windows, run some workers:</p>
</blockquote>
<p>在其他窗口上,执行worker进程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run -race mrworker.go wc.so</span><br></pre></td></tr></table></figure>

<blockquote>
<p>When the workers and coordinator have finished, look at the output in mr-out-*. When you’ve completed the lab, the sorted union of the output files should match the sequential output, like this:</p>
</blockquote>
<p>当执行成功后,查看mr-out-*中的输出,这些输出结果应该与提供的顺序版本的MapReduce的输出一致.像这样:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> mr-out-* | <span class="built_in">sort</span> | more</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>We supply you with a test script in main&#x2F;test-mr.sh. The tests check that the wc and indexer MapReduce applications produce the correct output when given the pg-xxx.txt files as input. The tests also check that your implementation runs the Map and Reduce tasks in parallel, and that your implementation recovers from workers that crash while running tasks.</p>
</blockquote>
<p>我们提供了一个测试脚本,位于main&#x2F;test-mr.sh.它会检查wc和indexer能否在以pg-xxx.txt文件作为输入时,产生正确的输出. 也会检查你的实现是否是并行的,以及能否在某些worker崩溃后恢复.</p>
<blockquote>
<p>If you run the test script now, it will hang because the coordinator never finishes:</p>
</blockquote>
<p>如果现在运行测试脚本，它将挂起，因为还没有完成Coordinator.</p>
<blockquote>
<p>You can change ret :&#x3D; false to true in the Done function in mr&#x2F;coordinator.go so that the coordinator exits immediately. Then:</p>
</blockquote>
<p>你可以将mr&#x2F;coordinator.go中的Done函数中的reg:&#x3D;false改为reg:&#x3D;true.这样Coordinator会立即退出.这样脚本就不会卡住了.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ bash test-mr.sh</span><br><span class="line">*** Starting <span class="built_in">wc</span> <span class="built_in">test</span>.</span><br><span class="line"><span class="built_in">sort</span>: No such file or directory</span><br><span class="line">cmp: EOF on mr-wc-all</span><br><span class="line">--- <span class="built_in">wc</span> output is not the same as mr-correct-wc.txt</span><br><span class="line">--- <span class="built_in">wc</span> <span class="built_in">test</span>: FAIL</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The test script expects to see output in files named mr-out-X, one for each reduce task. The empty implementations of mr&#x2F;coordinator.go and mr&#x2F;worker.go don’t produce those files (or do much of anything else), so the test fails.</p>
</blockquote>
<p>测试脚本期望的输出文件为mr-out-X,每个reduce任务对应一个文件.mr&#x2F;coordinator.go与mr&#x2F;worker.go的空实现不会生成这些输出,所以上面的测试会失败.</p>
<blockquote>
<p>When you’ve finished, the test script output should look like this:</p>
</blockquote>
<p>当你完成这个实验后,运行测试脚本,会得到类似于下面的输出:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ bash test-mr.sh</span><br><span class="line">*** Starting <span class="built_in">wc</span> <span class="built_in">test</span>.</span><br><span class="line">--- <span class="built_in">wc</span> <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting indexer <span class="built_in">test</span>.</span><br><span class="line">--- indexer <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting map parallelism <span class="built_in">test</span>.</span><br><span class="line">--- map parallelism <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting reduce parallelism <span class="built_in">test</span>.</span><br><span class="line">--- reduce parallelism <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting crash <span class="built_in">test</span>.</span><br><span class="line">--- crash <span class="built_in">test</span>: PASS</span><br><span class="line">*** PASSED ALL TESTS</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<blockquote>
<p>You’ll also see some errors from the Go RPC package that look like</p>
</blockquote>
<p>你会在Go PRC包中看到类似于下面的报错:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019/12/16 13:27:09 rpc.Register: method <span class="string">&quot;Done&quot;</span> has 1 input parameters; needs exactly three</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Ignore these messages; registering the coordinator as an RPC server checks if all its methods are suitable for RPCs (have 3 inputs); we know that Done is not called via RPC.</p>
</blockquote>
<p>忽略这些报错即可.将Coordinator注册为RPC server时检查Coordinator中的所有导出方法是否适合RPC的调用,但是我们知道Done并不是通过RPC调用的,所以不必理会.</p>
<h2 id="A-few-rules"><a href="#A-few-rules" class="headerlink" title="A few rules"></a>A few rules</h2><ul>
<li><p>The map phase should divide the intermediate keys into buckets for nReduce reduce tasks, where nReduce is the argument that main&#x2F;mrcoordinator.go passes to MakeCoordinator().</p>
</li>
<li><p>The worker implementation should put the output of the X’th reduce task in the file mr-out-X.</p>
</li>
<li><p>worker实现应该将第X个reduce任务的输出放在mr-out-X文件中</p>
</li>
<li><p>A mr-out-X file should contain one line per Reduce function output. The line should be generated with the Go “%v %v” format, called with the key and value. Have a look in main&#x2F;mrsequential.go for the line commented “this is the correct format”. The test script will fail if your implementation deviates too much from this format.</p>
</li>
<li><p>You can modify mr&#x2F;worker.go, mr&#x2F;coordinator.go, and mr&#x2F;rpc.go. You can temporarily modify other files for testing, but make sure your code works with the original versions; we’ll test with the original versions.</p>
</li>
<li><p>你可以修改mr&#x2F;worker.go、mr&#x2F;coordinator.go和mr&#x2F;rpc.go。你可以临时修改其他文件进行测试，但请确保代码与原始版本兼容；我们将使用原始版本进行测试。</p>
</li>
<li><p>The worker should put intermediate Map output in files in the current directory, where your worker can later read them as input to Reduce tasks.</p>
</li>
<li><p>Worker应该将中间的Map输出放在当前目录中,这样稍后的Workder可以将其作为Reduce任务的输入</p>
</li>
<li><p>main&#x2F;mrcoordinator.go expects mr&#x2F;coordinator.go to implement a Done() method that returns true when the MapReduce job is completely finished; at that point,mrcoordinator.go will exit.</p>
</li>
<li><p>main&#x2F;mrcoordinator.go期望mr&#x2F;coordinator.go实现一个Done方法.当MapReduce任务完成时,此函数返回true. 整个coordinator.go程序退出.</p>
</li>
<li><p>When the job is completely finished, the worker processes should exit. A simple way to implement this is to use the return value from call(): if the worker fails to contact the coordinator, it can assume that the coordinator has exited because the job is done, and so the worker can terminate too. Depending on your design, you might also find it helpful to have a “please exit” pseudo-task that the coordinator can give to workers.</p>
</li>
<li><p>当任务全部完成时,Worker进程应该退出.实现这一点可以使用call()的返回值: 如果Workder未能联系到Coordinator,可以假设Coordinator已经退出,因为任务已经完成,那么Worker也可以退出.这取决与你的设计,你可能会发现,如果Coordinator可以向Worker发送一个”退出”的伪任务,会很有用.</p>
</li>
</ul>
<h2 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h2><ul>
<li><p>One way to get started is to modify mr&#x2F;worker.go’s Worker() to send an RPC to the coordinator asking for a task. Then modify the coordinator to respond with the file name of an as-yet-unstarted map task. Then modify the worker to read that file and call the application Map function, as in mrsequential.go.</p>
</li>
<li><p>你可以从这个方面入手: 修改mr&#x2F;worker.go的worker(),通过RPC向Coordinator请求任务,然后修改Coordiantor,向Worker返回尚未启动的map任务对应的文件名.再然后,修改Worker,读取此文件,调用map程序.</p>
</li>
<li><p>The application Map and Reduce functions are loaded at run-time using the Go plugin package, from files whose names end in .so.</p>
</li>
<li><p>Map和Reduce应用程序在运行的时候从.so文件中通过Go plugin package动态加载</p>
</li>
<li><p>If you change anything in the mr&#x2F; directory, you will probably have to re-build any MapReduce plugins you use, with something like go build -race -buildmode&#x3D;plugin ..&#x2F;mrapps&#x2F;wc.go</p>
</li>
<li><p>如果你修改了mr&#x2F;目录下的内容,可能需要重新构建MapReduce插件,使用类似于go build-race-buildmode&#x3D;plugin..&#x2F;mrapps&#x2F;wc.go的命令</p>
</li>
<li><p>This lab relies on the workers sharing a file system. That’s straightforward when all workers run on the same machine, but would require a global filesystem like GFS if the workers ran on different machines.</p>
</li>
<li><p>这个实验需要worker程序们共享同一个文件系统.如果worker在同一台机器上,实现这一点很简单.如果在不同的机器上,就需要类似于GFS这种分布式文件系统了.</p>
</li>
<li><p>A reasonable naming convention for intermediate files is mr-X-Y, where X is the Map task number, and Y is the reduce task number.</p>
</li>
<li><p>一个比较合理的中间文件命名规则是这样的: mr-X-Y. 其中X是Map任务号,Y是Reduce任务号.</p>
</li>
<li><p>The worker’s map task code will need a way to store intermediate key&#x2F;value pairs in files in a way that can be correctly read back during reduce tasks. One possibility is to use Go’s encoding&#x2F;json package. To write key&#x2F;value pairs to a JSON file:</p>
</li>
<li><p>Worker的map任务需要一种在文件中存取中间键\值对的方法,你可以使用Go的encoding&#x2F;json包</p>
</li>
<li><p>The map part of your worker can use the ihash(key) function (in worker.go) to pick the reduce task for a given key.</p>
</li>
<li><p>worker的map部分可以使用ihash(key)函数(在worker.go中)为给定的键选择reduce任务</p>
</li>
<li><p>You can steal some code from mrsequential.go for reading Map input files, for sorting intermedate key&#x2F;value pairs between the Map and Reduce, and for storing Reduce output in files.</p>
</li>
<li><p>你可以借鉴一些mrsequential.go中代码来实现读取map输入,对map,reduce中间的键值对排序,以及将reduce的输入写入到文件(读书人的事情,怎么能叫偷呢)</p>
</li>
<li><p>The coordinator, as an RPC server, will be concurrent; don’t forget to lock shared data.</p>
</li>
<li><p>协调器作为RPC服务器会并发执行,别忘了加锁</p>
</li>
<li><p>Use Go’s race detector, with go build -race and go run -race. test-mr.sh by default runs the tests with the race detector.</p>
</li>
<li><p>在go build以及go run时加入-race来启用go的竞态检测,提前发现问题.不然test-mr.sh也会检测竞态问题的.</p>
</li>
<li><p>Workers will sometimes need to wait, e.g. reduces can’t start until the last map has finished. One possibility is for workers to periodically ask the coordinator for work, sleeping with time.Sleep() between each request. Another possibility is for the relevant RPC handler in the coordinator to have a loop that waits, either with time.Sleep() or sync.Cond. Go runs the handler for each RPC in its own thread, so the fact that one handler is waiting won’t prevent the coordinator from processing other RPCs.</p>
</li>
<li><p>Worker有时需要等待.比如,reduce任务需要所有map任务执行完成之后才能开始. 可以在每个请求间使用time.sleep(这个Sleep放在Worker或者Coordinator中都行),或者通过条件变量(sync.Cond)进行同步.Go的RPC调用是并发的,所以其中一个调用阻塞时,不会影响处理其他RPC请求.</p>
</li>
<li><p>The coordinator can’t reliably distinguish between crashed workers, workers that are alive but have stalled for some reason, and workers that are executing but too slowly to be useful. The best you can do is have the coordinator wait for some amount of time, and then give up and re-issue the task to a different worker. For this lab, have the coordinator wait for ten seconds; after that the coordinator should assume the worker has died (of course, it might not have).</p>
</li>
<li><p>Coordinator无法可靠地区分以下几种Worker</p>
<ol>
<li>已经崩溃的</li>
<li>仍然运行但是因为某些原因停止运行</li>
<li>执行速度太慢而无法使用</li>
</ol>
<p>  所以,最好让Coordinator等待一段时间,如果仍然不能响应,将这个任务重新分配给其他的Worker.在这个实验中,这个时间是10s,在此之后,Coordinator可以认为对应的Worker已经死亡</p>
</li>
<li><p>If you choose to implement Backup Tasks (Section 3.6), note that we test that your code doesn’t schedule extraneous tasks when workers execute tasks without crashing. Backup tasks should only be scheduled after some relatively long period of time (e.g., 10s).</p>
</li>
<li><p>如果你选择实现备份任务(3.6节),要注意,当worker执行备份任务并且没有崩溃时,我们会测试你的代码没有调度其他无关的任务.备份任务应该只在一段比较长的时间后被调度(<em><strong>这段还没看懂,先留个坑,回头再更详细地补充</strong></em>)</p>
</li>
<li><p>To test crash recovery, you can use the mrapps&#x2F;crash.go application plugin. It randomly exits in the Map and Reduce functions.</p>
</li>
<li><p>为了测试崩溃恢复,你可以使用mrapps&#x2F;crash.go崩溃会在map和reduce任务时随机发生</p>
</li>
<li><p>To ensure that nobody observes partially written files in the presence of crashes, the MapReduce paper mentions the trick of using a temporary file and atomically renaming it once it is completely written. You can use ioutil.TempFile to create a temporary file and os.Rename to atomically rename it.</p>
</li>
<li><p>为了确保在程序崩溃时不会出现部分写入的文件,MapReduce论文中提到了使用临时文件并在完全写入后自动重命名的技巧.你可以使用ioutil.TempFile创建一个临时文件,并使用os.Rename对其进行原子地重命名</p>
</li>
<li><p>test-mr.sh runs all the processes in the sub-directory mr-tmp, so if something goes wrong and you want to look at intermediate or output files, look there. You can modify test-mr.sh to exit after the failing test, so the script does not continue testing (and overwrite the output files).</p>
</li>
<li><p>test-mr.sh运行子目录mr-tmp中的所有进程,因此如果出现问题,您希望查看中间文件或输出文件,请查看那里.你可以修改test-mr.sh以在测试失败后退出,这样脚本就不会继续测试</p>
</li>
<li><p>test-mr-many.sh provides a bare-bones script for running test-mr.sh with a timeout (which is how we’ll test your code). It takes as an argument the number of times to run the tests. You should not run several test-mr.sh instances in parallel because the coordinator will reuse the same socket, causing conflicts.</p>
</li>
<li><p>test-mr-many.sh提供了一个用于运行带有超时的test-mr.sh的基本脚本(这就是我们测试代码的方式).它将运行测试的次数作为参数.因为你不应该并行运行多个test-mr.sh实例,因为协调器将重用同一套接字,从而导致冲突.</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">RiversJin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RiversJin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
